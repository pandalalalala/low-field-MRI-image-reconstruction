# low-field-MRI-image-reconstruction

#main.m starts from defining our FOV in X, Y matrices (assuming the initial position of Halbach array is upwards), and therefore the encoding matrix will be determined according to the FOV.

#enc_gen.m functions to generate this encoding matrix, while using the newly measured B0 field (B0_complete_measurement.mat) and Coil_Sensitivity.m.

#Coil_Sensitivity.m becomes relatively flexible than before, but keeps the majority of the original code. We can easily change the coil trajectory, number of coils and other properties in this function. Some other functions are prepared in case for later usage (including transform_traj.m)

#In the meantime, a phantom image is prepared, by brain_images_may_2018.m, and normalize_range.m is a very short function that helps normalize elements in an array from 0~1. (as the MATLAB built in function somehow does not work). We need to reshape this image phantom from a 2D matrix to an array.

#With the encoding matrix E generated by enc_gen.m, and the reshaped image m, we can calculate the simulated signal S using sig_gen_simul.m, it simply multiplies two matrices.

#LSMethod.m, Kaczmarz_su.m, TSVD.m are in sequence the functions of three method (lease square, iteration and TSVD), these three take nearly same input and generate output in the same format, so we can replace one with another easily.

#Then add_noise.m is used to give a noise to the signal simulated from sig_gen_simul.m, and now our signal is with noise.

#After the three methods could be again applied to solve the signal (with or without noise)

#cmp_image.m contains some of the functions to compare two matrices including NRMSE and etc., and it could be used to assess the reconstructed image with the original phantom.

#ele2zero.m and tikhonov.m are not used for now. 
#readme.txt contains a short description of some scripts.

